# mysql 


## 事务与隔离级别
一、事务四要素
- 原子性 （要么全部不完成、要么全部完成）
- 一致性 （只有在事务提交后，其他事务才可见）
- 隔离性 （不同的事务 相互不影响，适当的破坏隔离一致性，来提高性能）
- 持久性 数据到磁盘上持久化

二、事务并发问题
    1、脏读 事务未提交，其他事务就可读取
    2、不可重复读 同一事务中 同样条件读取的内容应该不一致
    3、幻读  同一事务中，同样条件 获取的结果集不一致
    4、丢失更新 :回滚覆盖、提交覆盖，针对于 递增或递减的
三、隔离级别
    1、读未提交  读取未提交的记录，会出现脏读、幻读、不可重复读
    2、读已提交 只有事务提交了，才能被读取 会出现 不可重复读、幻读的情况
    3、可重复读 事务提交可以被读取，会出现幻读(mysql 实现与标准sql 实现不一致， mysql是快照读、标准是加锁读) mysql 通过间隙锁解决了幻读问题
    4、序列化

四、隔离实现 （当前读、与快照读）
    1、传统的隔离级别
        - 读未提交 读取不加锁、写入加持续X锁 防止丢失更新 不会堵塞读 所以会出现脏读现象
        - 读已提交 读取加临时S锁，写入加持续X锁， SX 互斥、所以不会出现脏读、由于是临时读锁， 读取完成后，立马释放锁，其他事务可以获取到锁变更数据、当前事务再次获取临时S锁时，数据会读取到新变更的数据(出现 __不可重复读__ ) 可以把临时S锁 变更为持续S锁 实现可重复读
        - 可重复读 持续写锁，持续读锁
        - 序列化 表锁 或范围锁
    2、mysql 的隔离级别
        传统的模式，并发读没有问题，并发读写有问题，所以mysql 使用mvcc 模式 解决并发读写问题 实现
        > 新增一个事务ID
        > 新增一个回滚指针
        > 写操作 会复制一条原纪录，产生新记录， 给原纪录加锁，读取的会读取新纪录 
        > 快照读 不加锁，RC 读取最新的快照，RR 模式读取 事务开始时的快照  
        > 加锁读 = 当前读，读取当前版本，加读锁或写锁，其他进行不得 更改或查看
        > RC 只加记录锁 只会锁住 当前查出来的记录 RR 会加 间隙锁
    3、查看和设置mysql 隔离级别
        - 查看 select @@tx_isolation;
        - 设置 set transaction isolation level [read committed, read uncommitted,repeatable read, serializable];


## 常见锁
一、表锁 VS 行锁
    1、表锁 由mysql 服务器实现 所有的存储引擎 都可以使用 一次封锁技术，只能访问锁住表的数据
    2、行锁  由存储引擎实现，常用innodb
        - mysql 索引结构
            - 为什么不用二叉树？ 因为数据一般都在磁盘上，二叉树只有二个节点，需要比较的次数变的数，IO多，查询慢
            - 为什么不用B树？ 因为非叶子节点存储数据，导致节点存储的数据条数变少，这个时候，而且无法调整最大长度，除非重建数据库
            - B+树 非叶子节点不存储数据，扩展非叶子节点的存储数量
                - innodb 把数据存在叶子节点上
                - myisam 把数据单独存储，叶子节点存储数据地址
        - 加锁流程
            - update user set name = "ss" where id = 10 id 为主键， 则锁住 id = 10 的加上X锁
            - update user set name = "ss" where id > 10 id 为主键 则mysql 会每次拿一条锁住，更新后，释放锁，然后获得下一个锁... 整个过程是在mysql server 层 和存储引擎中执行的
            - update user set name = "s" where age = 10 age 为辅助索引 则锁住 age = 10 这个辅助索引，和 对应的主键索引
            - update user set name = "s" where age = 10 age 无索引， 则会退化成全表扫描，
        - 种类
            - 记录锁  锁行记录
            - 间隙锁  锁俩个行之间的数据
            - next-key  当前行 和 到下一行之间的间隙
            - 插入意向间隙锁

        
二、读锁和写锁
    1、类型
        - 行锁
        - 表锁
    2、模式
        - 读意向锁 由于innodb 支持行锁，当前事务拿到行锁，其他事务想要拿表锁的时候，只能遍历当前表，所有行判断是否有锁，才可以加行锁，意向锁解决了这个问题，当要拿读写锁，先加上意向锁，通知其他人，不可表锁
        - 写意向锁
        - 读锁
        - 写锁
        - 自增锁 
            - 自增锁 互不兼容
            - 不遵循二阶段协议，insert 结束 释放
            - 锁的值不会回滚
            - innodb_autoinc_lock_mode
                - 0 传统，并发性能差
                - 1 默认
                    - mysql 分为 三类插入语句
                    （1）知道插入数量 轻量
                    （2）不知道插入数量 表锁
                    （3）不确定是否要分配ID的 轻量 分析最坏情况 分配多少
                - 2 不会预分配，并发性能，但是同一个Insert 可能不连续，主从同步 会有问题
    3、详解锁种类 select * from information_schema.innodb_locks;
        - 记录锁 上文说过，主键会锁主键行，辅助会锁 辅助索引行 和主键 未命中会全表锁，引擎层处理完，server 会unlock 不合适的，减少锁冲突（不遵守二阶段协议）
        - 间隙锁 解决幻读问题，在RR 下会加， RC 下 不会加
        - next-key-lock  左开右闭
        - 插入意向锁（与表级的读写意向锁不同） 仅插入时 使用 先加间隙锁 再加插入意向锁 冲突
    4、乐观锁｜悲观锁

三、加锁分析
    1、主键索引
        - id = 10 命中，加记录锁
        - ID = 11 未命中 RC 不加锁， RR间隙锁
    2、唯一索引
        - key = 10 命中 加索引记录锁和主键记录锁
        - key = 11 未命中 RC 不加锁 RR只在索引加间隙锁
    3、普通索引
        - name = "哈哈" 命中 RC 索引记录锁和主键记录锁  RR 索引间隙锁 主键记录锁
        - name = “haha 1” 未命中 RC 不加锁， RR 索引间隙锁
    4、无索引
        - RC 索引层行锁，server 层 unlock  RR 索引层间隙锁需设置 innodb_locks_unsafe_for_binlog
    5、主键索引范围查找  （记录少 是否会 全表扫描）
        - RC 记录锁 
        - RR GAP next-key
    6、二级范围查找
        - RC 加记录锁
        - RR 索引间隙锁

四、索引筛选
    1、index key 、index filter 、table filter 前俩种 可以通过索引筛选，table filter 需要在server 筛选
    2、index key 联合索引 需同时指定上边界 或同时指定下边界，否则只能用上icp 过滤
        - 下边界 >= = 必须含有等号 
        - 上边界 <= = 必须含有等号
    3、between a and b  等价于 x >= a and x <= b
    4、like a% 等价于 x >= a and x <= b
    

